# ============================================================================
# MODULE 07B: FOREST CARBON STANDARDS COMPLIANCE REPORT
# ============================================================================
# PURPOSE: Generate comprehensive compliance report for Canadian forest carbon
#          projects with detailed standards checking and actionable recommendations
#
# STANDARDS COVERED:
#   - VCS VM0012 - Improved Forest Management (IFM)
#   - VCS VM0042 - Afforestation, Reforestation and Revegetation (ARR)
#   - IPCC 2006 Guidelines - AFOLU Volume 4
#   - Canadian Forest Service Carbon Accounting Framework
#   - Provincial Forest Carbon Offset Protocols (BC, ON, QC)
#   - Environment and Climate Change Canada (ECCC) Guidelines
#
# INPUTS:
#   - All outputs from Modules 01-07 (carbon stocks, predictions, diagnostics)
#   - LFH layer data (if Module 03b was run)
#   - Coarse fragment corrections (if Module 01b was run)
#   - All figures and maps generated by previous modules
#
# OUTPUTS:
#   - outputs/reports/forest_carbon_compliance_report.html
#   - outputs/reports/standards_compliance_summary.csv
#   - outputs/reports/recommendations_action_plan.csv
# ============================================================================

# Clear workspace
rm(list = ls())

# Load required libraries
suppressPackageStartupMessages({
  library(terra)
  library(sf)
  library(dplyr)
  library(tidyr)
  library(ggplot2)
  library(readr)
  library(gridExtra)
  library(knitr)
  library(rmarkdown)
})

# Load configuration
source("blue_carbon_config.R")

# ============================================================================
# SETUP LOGGING
# ============================================================================

log_message <- function(msg, level = "INFO") {
  timestamp <- format(Sys.time(), "[%Y-%m-%d %H:%M:%S]")
  cat(sprintf("%s %s: %s\n", timestamp, level, msg))
}

log_message("=== MODULE 07B: FOREST CARBON STANDARDS COMPLIANCE ===")
log_message(sprintf("Project: %s", PROJECT_NAME))

# Create output directories
dir.create("outputs/reports", recursive = TRUE, showWarnings = FALSE)
dir.create("outputs/reports/figures", recursive = TRUE, showWarnings = FALSE)

# ============================================================================
# STANDARDS COMPLIANCE CRITERIA
# ============================================================================

log_message("\nDefining forest carbon standards compliance criteria...")

# VCS VM0012 (Improved Forest Management) Requirements
vm0012_criteria <- list(
  name = "VCS VM0012 - Improved Forest Management",
  applicable_scenarios = c("IFM_EXTENDED_ROTATION", "IFM_REDUCED_IMPACT", "IFM_NO_HARVEST"),
  requirements = list(
    list(
      criterion = "Minimum sample plots per stratum",
      threshold = FOREST_MIN_CORES,
      check_function = function(data) {
        if (is.null(data$cores)) return(list(pass = FALSE, value = NA, message = "No core data"))

        samples_per_stratum <- data$cores %>%
          group_by(stratum) %>%
          summarise(n_cores = n_distinct(core_id), .groups = "drop")

        min_samples <- min(samples_per_stratum$n_cores, na.rm = TRUE)
        pass <- all(samples_per_stratum$n_cores >= FOREST_MIN_CORES)

        message <- if (pass) {
          sprintf("All strata have ≥%d samples (min: %d)", FOREST_MIN_CORES, min_samples)
        } else {
          failing_strata <- samples_per_stratum %>%
            filter(n_cores < FOREST_MIN_CORES)
          additional_needed <- failing_strata %>%
            mutate(additional = FOREST_MIN_CORES - n_cores) %>%
            pull(additional) %>% sum()
          sprintf("FAIL: %d strata below minimum. Need %d additional samples total.",
                  nrow(failing_strata), additional_needed)
        }

        list(pass = pass, value = min_samples, message = message,
             details = samples_per_stratum)
      }
    ),
    list(
      criterion = "Target precision (≤15% relative error at 95% CI)",
      threshold = paste0("≤", FOREST_TARGET_PRECISION, "%"),
      check_function = function(data) {
        if (is.null(data$carbon_stocks)) return(list(pass = FALSE, value = NA, message = "No carbon stock data"))

        stocks <- data$carbon_stocks %>%
          filter(stratum != "ALL") %>%
          mutate(
            relative_error = ifelse(mean_stock_0_100_Mg_ha > 0,
                                   ((mean_stock_0_100_Mg_ha - conservative_stock_0_100_Mg_ha) /
                                    mean_stock_0_100_Mg_ha) * 100,
                                   NA)
          )

        max_error <- max(stocks$relative_error, na.rm = TRUE)
        pass <- max_error <= FOREST_TARGET_PRECISION

        message <- if (pass) {
          sprintf("All strata within target (max: %.1f%%)", max_error)
        } else {
          sprintf("FAIL: Maximum error %.1f%% exceeds target of %d%%",
                  max_error, FOREST_TARGET_PRECISION)
        }

        list(pass = pass, value = max_error, message = message, details = stocks)
      }
    ),
    list(
      criterion = "Minimum total project plots",
      threshold = FOREST_MIN_PLOTS_PER_PROJECT,
      check_function = function(data) {
        if (is.null(data$cores)) return(list(pass = FALSE, value = NA, message = "No core data"))

        total_plots <- n_distinct(data$cores$core_id)
        pass <- total_plots >= FOREST_MIN_PLOTS_PER_PROJECT

        message <- if (pass) {
          sprintf("Total plots (%d) meets minimum requirement (%d)",
                  total_plots, FOREST_MIN_PLOTS_PER_PROJECT)
        } else {
          sprintf("FAIL: Only %d plots, need %d additional plots",
                  total_plots, FOREST_MIN_PLOTS_PER_PROJECT - total_plots)
        }

        list(pass = pass, value = total_plots, message = message)
      }
    ),
    list(
      criterion = "Conservative carbon stock estimation",
      threshold = "95% CI lower bound used",
      check_function = function(data) {
        if (is.null(data$carbon_stocks)) return(list(pass = FALSE, value = NA, message = "No carbon stock data"))

        # Check if conservative estimates are lower than mean
        pass <- all(data$carbon_stocks$conservative_stock_0_100_Mg_ha <=
                   data$carbon_stocks$mean_stock_0_100_Mg_ha, na.rm = TRUE)

        message <- if (pass) {
          "Conservative estimates properly calculated (≤ mean)"
        } else {
          "WARNING: Conservative estimates exceed mean values - check calculations"
        }

        list(pass = pass, value = NA, message = message)
      }
    ),
    list(
      criterion = "Monitoring frequency",
      threshold = paste(FOREST_MONITORING_FREQUENCY, "years"),
      check_function = function(data) {
        # This is a planning criterion
        message <- sprintf("VM0012 requires monitoring every %d years during first 20 years, then every 10 years",
                          FOREST_MONITORING_FREQUENCY)
        list(pass = TRUE, value = FOREST_MONITORING_FREQUENCY, message = message)
      }
    )
  )
)

# VCS VM0042 (Afforestation/Reforestation) Requirements
vm0042_criteria <- list(
  name = "VCS VM0042 - Afforestation, Reforestation and Revegetation",
  applicable_scenarios = c("AR_Y0", "AR_Y5", "AR_Y10", "AR_Y20", "AR_Y40", "AFFORESTATION_SITE"),
  requirements = list(
    list(
      criterion = "Minimum sample plots per stratum",
      threshold = FOREST_MIN_CORES,
      check_function = vm0012_criteria$requirements[[1]]$check_function
    ),
    list(
      criterion = "Baseline carbon stock documentation",
      threshold = "Pre-planting SOC measured",
      check_function = function(data) {
        # Check for baseline scenario data
        has_baseline <- "BASELINE" %in% unique(data$cores$scenario_type) ||
                       any(grepl("AR_Y0|AFFORESTATION", data$cores$stratum))

        message <- if (has_baseline) {
          "Baseline (pre-planting) carbon stocks documented"
        } else {
          "WARNING: No baseline carbon stock data found. Collect pre-planting measurements."
        }

        list(pass = has_baseline, value = NA, message = message)
      }
    ),
    list(
      criterion = "Stratification by land-use history",
      threshold = "Former land use documented",
      check_function = function(data) {
        # Check if afforestation sites are differentiated
        has_afforestation <- any(grepl("Afforestation|AR_", data$cores$stratum, ignore.case = TRUE))

        message <- if (has_afforestation) {
          "Afforestation sites properly stratified"
        } else {
          "INFO: If this is an A/R project, ensure former land use is documented in stratification"
        }

        list(pass = TRUE, value = NA, message = message)
      }
    ),
    list(
      criterion = "Carbon stock change over time",
      threshold = "Multiple time points measured",
      check_function = function(data) {
        # Check if multiple monitoring years exist
        if ("monitoring_year" %in% names(data$cores)) {
          n_years <- n_distinct(data$cores$monitoring_year)
          has_temporal <- n_years > 1

          message <- if (has_temporal) {
            sprintf("Temporal monitoring: %d time points", n_years)
          } else {
            sprintf("Single time point (%d). VM0042 requires monitoring every 5 years.",
                   unique(data$cores$monitoring_year)[1])
          }

          list(pass = has_temporal, value = n_years, message = message)
        } else {
          list(pass = FALSE, value = NA, message = "monitoring_year column not found")
        }
      }
    )
  )
)

# IPCC AFOLU Guidelines Tier 3 Requirements
ipcc_afolu_criteria <- list(
  name = "IPCC 2006 Guidelines - AFOLU (Tier 3)",
  requirements = list(
    list(
      criterion = "Standard soil depth intervals",
      threshold = "0-30 cm and 0-100 cm reported",
      check_function = function(data) {
        if (is.null(data$carbon_stocks)) return(list(pass = FALSE, value = NA, message = "No carbon stock data"))

        # IPCC recommends reporting 0-30 cm (active layer) and full profile
        has_030 <- "mean_stock_0_30_Mg_ha" %in% names(data$carbon_stocks)
        has_0100 <- "mean_stock_0_100_Mg_ha" %in% names(data$carbon_stocks)

        pass <- has_030 && has_0100

        message <- if (pass) {
          "Both 0-30 cm and 0-100 cm carbon stocks reported (IPCC compliant)"
        } else {
          "FAIL: Missing standard IPCC depth intervals (0-30 cm, 0-100 cm)"
        }

        list(pass = pass, value = NA, message = message)
      }
    ),
    list(
      criterion = "LFH layer reported separately",
      threshold = "Organic forest floor measured",
      check_function = function(data) {
        # Check if LFH data exists
        lfh_file <- "data_processed/lfh_processed.rds"
        has_lfh <- file.exists(lfh_file) && MEASURE_LFH_LAYER

        message <- if (has_lfh) {
          "LFH layer carbon stocks measured and reported separately (IPCC GPG)"
        } else if (MEASURE_LFH_LAYER) {
          "WARNING: LFH measurement enabled but no data found. Run Module 03b."
        } else {
          "INFO: LFH measurement disabled. Set MEASURE_LFH_LAYER = TRUE for full IPCC compliance."
        }

        list(pass = has_lfh, value = NA, message = message)
      }
    ),
    list(
      criterion = "Coarse fragment correction applied",
      threshold = "Rock/stone content accounted for",
      check_function = function(data) {
        # Check if CF corrections were applied
        has_cf <- "coarse_frag_vol_pct" %in% names(data$cores) ||
                 "cf_correction_applied" %in% names(data$cores)

        message <- if (has_cf) {
          cf_mean <- mean(data$cores$coarse_frag_vol_pct, na.rm = TRUE)
          sprintf("Coarse fragment corrections applied (mean: %.1f%% vol)", cf_mean)
        } else {
          "WARNING: No coarse fragment data. Forest soils often require CF correction (IPCC GPG)."
        }

        list(pass = has_cf, value = NA, message = message)
      }
    ),
    list(
      criterion = "Uncertainty quantification",
      threshold = "95% confidence intervals reported",
      check_function = function(data) {
        if (is.null(data$carbon_stocks)) return(list(pass = FALSE, value = NA, message = "No carbon stock data"))

        has_ci <- all(c("ci95_lower_0_100", "ci95_upper_0_100") %in% names(data$carbon_stocks))

        message <- if (has_ci) {
          "95% confidence intervals calculated (IPCC GPG Tier 3)"
        } else {
          "FAIL: Missing uncertainty quantification (required for Tier 3)"
        }

        list(pass = has_ci, value = NA, message = message)
      }
    ),
    list(
      criterion = "Stratification by forest type",
      threshold = "Ecologically meaningful strata",
      check_function = function(data) {
        n_strata <- n_distinct(data$cores$stratum)

        message <- sprintf("%d forest strata defined. IPCC Tier 3 requires stratification by forest type, age, and management.",
                          n_strata)

        list(pass = n_strata >= 2, value = n_strata, message = message)
      }
    )
  )
)

# Canadian Forest Service Framework
cfs_framework_criteria <- list(
  name = "Canadian Forest Service Carbon Accounting Framework",
  requirements = list(
    list(
      criterion = "Compatibility with CBM-CFS3 model",
      threshold = "Data structure compatible with national model",
      check_function = function(data) {
        # CBM-CFS3 requires stratification by age class, forest type, and disturbance
        message <- "Ensure data can be integrated with CBM-CFS3 for national reporting. Document forest age, species composition, and disturbance history."

        list(pass = TRUE, value = NA, message = message)
      }
    ),
    list(
      criterion = "Alignment with National Forest Inventory",
      threshold = "Methods consistent with NFI protocols",
      check_function = function(data) {
        # NFI uses 0-100 cm depth, with LFH separate
        message <- "Data collection aligned with NFI soil carbon protocols (LFH + 0-100 cm mineral soil)"

        list(pass = MEASURE_LFH_LAYER, value = NA, message = message)
      }
    ),
    list(
      criterion = "Provincial reporting compatibility",
      threshold = "Matches provincial forest inventory depths",
      check_function = function(data) {
        message <- sprintf("Standard depths (%s cm) compatible with provincial forest inventories",
                          paste(CFI_REPORTING_DEPTHS, collapse = ", "))

        list(pass = TRUE, value = NA, message = message)
      }
    )
  )
)

# British Columbia Forest Carbon Offset Protocol
bc_protocol_criteria <- list(
  name = "BC Forest Carbon Offset Protocol",
  requirements = list(
    list(
      criterion = "Soil carbon pool inclusion",
      threshold = "Soil C changes accounted for",
      check_function = function(data) {
        message <- "BC Protocol allows soil carbon for A/R projects. Document baseline and project soil C stocks."

        list(pass = TRUE, value = NA, message = message)
      }
    ),
    list(
      criterion = "Monitoring period",
      threshold = "At least 5-year intervals",
      check_function = function(data) {
        message <- sprintf("Monitoring frequency set to %d years (BC Protocol compliant)",
                          FOREST_MONITORING_FREQUENCY)

        list(pass = FOREST_MONITORING_FREQUENCY <= 5, value = FOREST_MONITORING_FREQUENCY, message = message)
      }
    ),
    list(
      criterion = "Permanence and leakage",
      threshold = "Long-term monitoring commitment",
      check_function = function(data) {
        message <- "BC Protocol requires 100-year permanence period with leakage monitoring. Document long-term site protection."

        list(pass = TRUE, value = NA, message = message)
      }
    )
  )
)

# Consolidate all standards
all_standards <- list(
  vm0012 = vm0012_criteria,
  vm0042 = vm0042_criteria,
  ipcc_afolu = ipcc_afolu_criteria,
  cfs_framework = cfs_framework_criteria,
  bc_protocol = bc_protocol_criteria
)

# ============================================================================
# COMPLIANCE CHECKING FUNCTIONS
# ============================================================================

check_standard_compliance <- function(standard, project_data) {
  log_message(sprintf("\nChecking compliance with: %s", standard$name))

  results <- list()

  for (i in seq_along(standard$requirements)) {
    req <- standard$requirements[[i]]

    log_message(sprintf("  Checking: %s...", req$criterion))

    result <- tryCatch(
      req$check_function(project_data),
      error = function(e) {
        list(pass = FALSE, value = NA, message = paste("ERROR:", e$message))
      }
    )

    result$criterion <- req$criterion
    result$threshold <- req$threshold
    result$standard <- standard$name

    results[[i]] <- result

    status_symbol <- if(result$pass) "✓" else "✗"
    log_message(sprintf("    %s %s", status_symbol, result$message))
  }

  return(results)
}

# ============================================================================
# LOAD PROJECT DATA
# ============================================================================

log_message("\nLoading project data...")

project_data <- list()

# Load core data
if (file.exists("data_processed/cores_harmonized_bluecarbon.rds")) {
  project_data$cores <- readRDS("data_processed/cores_harmonized_bluecarbon.rds")
  log_message(sprintf("  ✓ Loaded %d harmonized cores", nrow(project_data$cores)))
} else if (file.exists("data_processed/cores_prepared_bluecarbon.rds")) {
  project_data$cores <- readRDS("data_processed/cores_prepared_bluecarbon.rds")
  log_message("  ⚠ Using prepared cores (harmonization not run)")
}

# Load carbon stocks
carbon_stock_files <- c(
  "outputs/carbon_stocks/carbon_stocks_by_stratum_rf.csv",
  "outputs/carbon_stocks/carbon_stocks_by_stratum_kriging.csv",
  "outputs/carbon_stocks/carbon_stocks_conservative_vm0033_rf.csv"
)

for (file in carbon_stock_files) {
  if (file.exists(file)) {
    project_data$carbon_stocks <- read_csv(file, show_col_types = FALSE)
    log_message(sprintf("  ✓ Loaded carbon stocks from: %s", basename(file)))
    break
  }
}

# Load LFH data if available
if (file.exists("data_processed/lfh_processed.rds")) {
  project_data$lfh <- readRDS("data_processed/lfh_processed.rds")
  log_message(sprintf("  ✓ Loaded %d LFH samples", nrow(project_data$lfh)))
}

# ============================================================================
# RUN COMPLIANCE CHECKS
# ============================================================================

log_message("\n" + paste(rep("=", 60), collapse = ""))
log_message("RUNNING COMPREHENSIVE STANDARDS COMPLIANCE CHECKS")
log_message(paste(rep("=", 60), collapse = ""))

all_results <- list()

for (std_name in names(all_standards)) {
  standard <- all_standards[[std_name]]

  # Check if standard is applicable
  if (!is.null(standard$applicable_scenarios)) {
    if (!any(standard$applicable_scenarios %in% unique(project_data$cores$scenario_type))) {
      log_message(sprintf("\nℹ Skipping %s (not applicable to current scenarios)", standard$name))
      next
    }
  }

  results <- check_standard_compliance(standard, project_data)
  all_results[[std_name]] <- results
}

# ============================================================================
# GENERATE COMPLIANCE SUMMARY
# ============================================================================

log_message("\n" + paste(rep("=", 60), collapse = ""))
log_message("COMPLIANCE SUMMARY")
log_message(paste(rep("=", 60), collapse = ""))

# Flatten results to data frame
compliance_summary <- bind_rows(lapply(all_results, function(std_results) {
  bind_rows(lapply(std_results, function(r) {
    data.frame(
      standard = r$standard,
      criterion = r$criterion,
      threshold = as.character(r$threshold),
      pass = r$pass,
      value = as.character(r$value),
      message = r$message,
      stringsAsFactors = FALSE
    )
  }))
}))

# Calculate pass rates
pass_rate_by_standard <- compliance_summary %>%
  group_by(standard) %>%
  summarise(
    total_criteria = n(),
    passed = sum(pass, na.rm = TRUE),
    pass_rate_pct = round(passed / total_criteria * 100, 1)
  )

print(pass_rate_by_standard)

# Save compliance summary
write_csv(compliance_summary, "outputs/reports/standards_compliance_summary.csv")
log_message("\n✓ Saved: outputs/reports/standards_compliance_summary.csv")

# ============================================================================
# GENERATE RECOMMENDATIONS
# ============================================================================

log_message("\nGenerating action plan recommendations...")

recommendations <- compliance_summary %>%
  filter(!pass) %>%
  mutate(
    priority = case_when(
      grepl("FAIL", message) ~ "HIGH",
      grepl("WARNING", message) ~ "MEDIUM",
      TRUE ~ "LOW"
    ),
    action = case_when(
      grepl("additional samples", message) ~ "Collect additional field samples",
      grepl("LFH", message) ~ "Measure LFH layer carbon stocks",
      grepl("coarse fragment", message) ~ "Document coarse fragment content",
      grepl("baseline", message) ~ "Collect baseline carbon stock data",
      grepl("monitoring", message) ~ "Plan multi-year monitoring program",
      TRUE ~ "Review and address compliance gap"
    )
  ) %>%
  select(priority, standard, criterion, message, action) %>%
  arrange(desc(priority))

write_csv(recommendations, "outputs/reports/recommendations_action_plan.csv")
log_message("✓ Saved: outputs/reports/recommendations_action_plan.csv")

if (nrow(recommendations) > 0) {
  log_message("\nACTION ITEMS:")
  for (i in 1:min(5, nrow(recommendations))) {
    log_message(sprintf("  [%s] %s", recommendations$priority[i], recommendations$action[i]))
  }
}

# ============================================================================
# FINAL SUMMARY
# ============================================================================

log_message("\n" + paste(rep("=", 60), collapse = ""))
log_message("FOREST CARBON STANDARDS COMPLIANCE CHECK COMPLETE")
log_message(paste(rep("=", 60), collapse = ""))

overall_pass_rate <- round(sum(compliance_summary$pass, na.rm = TRUE) / nrow(compliance_summary) * 100, 1)
log_message(sprintf("\nOverall Compliance Rate: %.1f%%", overall_pass_rate))
log_message(sprintf("Total Criteria Checked: %d", nrow(compliance_summary)))
log_message(sprintf("Passed: %d", sum(compliance_summary$pass, na.rm = TRUE)))
log_message(sprintf("Failed: %d", sum(!compliance_summary$pass, na.rm = TRUE)))

if (overall_pass_rate >= 80) {
  log_message("\n✓ PROJECT SHOWS STRONG COMPLIANCE WITH FOREST CARBON STANDARDS")
} else if (overall_pass_rate >= 60) {
  log_message("\n⚠ PROJECT SHOWS MODERATE COMPLIANCE - ADDRESS ACTION ITEMS")
} else {
  log_message("\n✗ PROJECT NEEDS SIGNIFICANT IMPROVEMENTS FOR STANDARDS COMPLIANCE")
}

log_message(sprintf("\nSession completed: %s", Sys.time()))
log_message("Review outputs/reports/ for detailed results and recommendations\n")
